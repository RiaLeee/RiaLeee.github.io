---
title: SQLD1
date: 2024-11-19 +09:00
categories: [Certificate, SQLD]
tags: 
  - SQLD
  - SQL
  - SQL개발자
  - 개발자자격증
  - 개발자격증
  - Oracle
  - SQL-Server
  - 자격증
excerpt: "SQLD 제1과목 데이터 모델링의 이해 정리"
---
<!--more-->
# 🔥SUMMARY
## 1장. 데이터 모델링의 이해

*데이터 모델링의 3요소: Things, Attributes, Relationships
*데이터 모델링의 특징: 추상화, 단순화, 명확성

*데이터 모델링 단계
 1) 개념적 모델링 (엔터티, 속성)
  - 추상화 수준이 가장 높은 모델, 전사적 관점
 2) 논리적 모델링 (식별자 정의)
  - 정규화 수행 -> 독립성 및 재사용성
  ** 논리 모델링의 외래키는 물리 모델에서 반드시 구현되지 않는 선택 사항임.
 3) 물리적 모델링 (테이블, 인덱스, 함수 생성)
  -실제 데이터 구축 시 참고되는 모델 >> 성능 높아짐

*슈퍼/서브 타입 모델 : 논리적 데이터 모델링 모델에서 이용됨.
*이를 고려한 물리적인 데이터 모델에서 변환하는 방법
1:1 타입, 슈퍼+서브 타입, All in One 타입

*슈퍼/서브 타입 간의 관계
 -배타적 관계(X) : 각 인스턴스가 오직 하나의 서브 타입에만 속하는 경우
 -포괄적 관계(O) : 각 인스턴스가 여러 서브 타입에 동시에 속할 수 있는 경우

*데이터 모델링을 할 때 3가지 관점
 - 데이터 에 대한 관점(What, Data) (ex. 정적 분석)
 - 프로세스에 대한 관점(How, Process) (ex. 동적 분석)
 - 데이터와 프로세스가 서로 연관성이 표현되는 상관 관점(Interaction) (ex. CRUD분석)

*ERD 작성 절차
1) 엔터티 도출
2) 엔터티 배치: 중요한 엔터티는 왼쪽 상단
3) 엔터티 관계 설정
4) 엔터티 관계명 서술
5) 관계 참여도
6) 관계의 필수 여부 표현

![ERD](/assets/img/sqld/erd.PNG)


* 3층 스키마의 구조
1) 외부 스키마(사용자 관점): 뷰 표시, 응용 프로그램 접근
2) 개념 스키마(설계자 관점): 통합 DB구조
3) 내부 스키마(개발자 관점): 물리적 저장구조

*3층 스키마의 독립성
1) 논리적 독립성 : 개념 스키마가 변경되도 외부 스키마 영향X
2) 물리적 독립성 : 내부 스키마가 변경되도 개념 스키마 영향X


*엔터티(Entity) 3가지 공통점
-개념, 사건, 사람, 장소 등과 같이 명사로 구성
- 비즈니스 프로세스에서 관리되어야 하는 정보
-저장이 필요한 어떤 것(Things)

*엔터티-인스턴스-속성-속성값에 대한 관계
- 1개의 엔터티는 2개 이상의 인스턴스 집합 임
- 1개의 엔터티는 2개 이상의 속성을 가짐.
- 엔터티 1개의 인스턴스는 다른 엔터티의 인스턴스 간 관계인 Pairing을 가짐.
- 1개의 속성은 1개의 속성값을 가짐 >> 1개 이상의 속성값을 가질경우, 정규화 필요!

*엔터티 유형
1) 발생 시점에 따라
 - 기본/핵심 엔터티 (Basic Entity) = 키 엔터티
 - 중심 엔터티 (Main Entity): 기본과 행위의 중간
 - 행위 엔터티 (Active Entity): 2개 이상의 엔터티로부터 발생

2) 물리적 형태의 존재 여부에 따라
 - 유형 엔터티: 물리적 형태 O (ex. 고객)
 - 개념 엔터티: 물리적 형태X (ex. 생명보험 상품) 
 - 사건 엔터티 (ex. 체결)

*교차 엔터티(Association Entity, Relationship Entity, Intersection Entity)
 : 다:다 관계를 해소하기 위해 인위적으로 만들어진 엔터티

*속성의 종류
1) 기본 속성: 설계 및 파생 속성 제외한 모든 속성
2) 설계 속성
 -업무를 규칙화하기 위해 속성을 새로 만들거나 변형하는 속성
 -단일한 식별자를 부여하기 위해 모델 상에서 새로 정의하는 속성
3) 파생 속성(Derived Attribute)
 -다른 속성에 영향을 받아 발생하는 속성 >> 주로 계산된 값들이 해당

4) 단일 속성 : 하나의 의미로 구성된 것 (ex. 회원 id, 이름)
5) 복합 속성 : 여러 개의 의미로 구성된 것 (ex. 주소/시,군,동 으로 분해 가능)
6) 다중값 속성 : 속성에 여러 개의 값을 가질 수 있는 것 (ex. 상품리스트) >엔터티로 분해 가능

*속성명 : 업무에서 사용하는 명칭 >> 데이터 모델에서 유일하게 사용해야 함.

*카디널리티(Cardinality) : 두 개의 엔터티에서 관계에 참여하는 수
*카디널리티 계산식 : 선택도*전체 레코드 수

*기본키(주식별자, Primary Key) 특징 : 최소성, 대표성, 유일성, 불변성, 존재성
*주식별자 특징
 -주식별자가 지정되면 반드시 값이 들어와야 함. (존재성)
-주식별자의 값은 자주 변하지 않는 것이어야 함.(불변성) >>유일하게 구분되는 값이어야 함.(유일성)
-주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함. (최소성)

*데이터베이스 키의 종류
-기본키(Primary Key) : 후보키 중에서 엔터티를 대표할 수 있는 키
-후보키(Candidate Key): 유일성과 최소성을 만족하는 키
-슈퍼키(Super Key): 유일성 만족, 최소성(not null)은 불만족
-대체키(Alternate Key): 여러 후보키 중 기본키를 선정하고 남은 키
-외래키(Foreign Key): 다른 케이블의 기본키 필드를 가리키는 것 >>참조 무결성 확인을 위한 키

*고유키(Unique Key)로 지정된 칼럼은 Null 값 가질 수 있음. (중복 X)

*정규화(=테이블 분리) 과정
-정규화를 진행하면서 (1)테이블이 더 작은 단위로 분리되고, (2) 중복 데이터가 제거되며,
(3) 데이터의 무결성이 유지됨.

1) 제1정규화(1NF)
 -모든 열이 단일 값(원자 값)만 가지도록
2) 제2정규화(2NF)
 -부분적 함수 종속성을 제거하여 기본 키의 모든 속성에 완전 종속되도록
 -부분적 종속성 : x에서 종속 발생(x와 y끼리)

3) 제3정규화(3NF)
 -이행적 종속성을 제거하여 모든 비프라이머리 속성이 기본 키에만 종속되도록
 -이행적 종속성 : y에서 종속 발생(y끼리) (=기본 키를 제외하고 칼럼 간에 종속성 발생 경우)

4) 보이스-코드 정규화(BCNF): 다수의 주식별자를 분리시킴.
 -제3정규형에서 비프라이머리 속성이 다른 비프라이머리 속성에 종속되는 것을 방지
5) 제4정규화(4NF): 다치 종속(Multi-Valued DEpendency) 을 제거하여 중복 데이터 방지
 -다치 종속: 특정 속성의 값이 다른 속성의 값에 의해 다중으로 결정되는 것
6) 제5정규화(5NF): 조인 종속성을 제거하여 완전한 독립성 유지 (테이블 분리)
결합 종속일 경우, 다수의 테이블로 분리시킴.

*관계를 정의할때 주요하게 체크해야 하는 사항
 - 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가?
 - 2개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?
 - 2개의 엔터티 사이에 정보의 조합이 발생되는가?

*비식별자 관계(Non-Identifying re-lationship): 부모 엔터티로부터 속성을 받았지만, 자식 엔터티의 주식별자로 사용하지 않고, 일반적인 속성으로만 사용하는 것(약한 연결 관계)
*식별 관계 (강한 연결 관계를 표현)

*ER모델링 표기법 : IE 표기법(대부분), Barker 표기법(점선 있음)

*성능을 고려한 데이터베이스 모델링 과정
1) 데이터베이스 모델링 시에 정규화를 수행한다 >> 독립성 향상시켜야 함.
필요에 따라
2) 트랜잭션의 유형 및 데이터베이스 전체 용량 산정
3) 반정규화, 키 및 타입 조정
4) 성능관점에서 데이터 모델을 검증하고 확인한다

*Rownum은 Oracle에서 사용 / Top구 는 SQL Server
*Top 구에서 With Ties 를 같이 사용 시, 동일한 데이터가 있을 때 함께 조회됨.SQL Server

*식별자의 종류
1) 대표성 여부에 따른 : 주식별자(대표성O), 보조식별자(대표성X)
2) 생성 여부에 따른 : 내부 식별자, 외부 식별자
3) 속성의 수에 따른 : 단일 식별자(속성 1개), 복합 식별자(속성 2개 이상)
4) 대체 여부에 따른 : 본질 식별자, 인조 식별자(ex.시퀀스 식별자)

*주식별자 도출 기준 : 자주 이용되는 것 (자주 변경되는 건 X)

*분산 데이터베이스 >> 무결성 보장이 어려움,
 -정의: 데이터가 여러 물리적 위치에 분산되어 저장된 데이터베이스 시스템
 -목적: 시스템 전체의 성능, 가용성, 신뢰성 향상
 -특징: 데이터 분산성, 각 위치별 독립적 데이터 처리, 일관성 유지, 높은 가용성, 확장성
 -장점: 확장성, 가용성, 성능 향상, 신뢰성
 -단점: 비용 증가, 복잡성 증가, 오류 잠재성 증가, 일관성 유지 문제 

*분산 데이터베이스의 투명성
-투명성: 사용자가 분산 데이터베이스를 하나의 단일 시스템처럼 인식하도록 하는 것
1) 데이터 위치 투명성 : 사용자가 데이터 요청 시, 데이터 위치 정보 모르도록
2) 중복 투명성 : 데이터가 여러 복제본이 있어도, 단일 데이터베이스처럼 접근
3) 병행 투명성 : 여러 사용사가 요청 시, 각 사용자들이 병행 처리 인식 못하게(트랜잭션 관리, 동시성 제어)
4) 장애 투명성 : 특정 노드가 장애여도, 사용자가 모르도록 (일관성, 무결성 보장)
5) 분할 투명성 : 여러 조각으로 분할되어 있는 데이터를 사용자가 모르도록
6) 지역 사상 투명성 : 지역 DBMS와 물리적 데이터베이스 사이의 사상이 보장되므로 각 지역 시스템 이름과 무관한 이름 사용 가능

*해시 조인(Hash Join)
-CPU 연산이 많이 발생되는 조인 >> 선행 테이블의 크기가 작아야 유리
-대용량 데이터 조인 시 유리함.
-선행 테이블이 필수 (해시 테이블을 메모리에 생성되어야 함.)
-조인 칼럼의 인덱스가 존재하지 않을 경우도 사용 가능
-동등조건에서만 사용 가능
-동일한 값은 항상 같은 값으로 해시됨
-선행 테이블(=Build Input), 후행 테이블(Prove Input)

*B-Tree 인덱스
-정보계와 같은  Data warehouse에서 사용하고, 많은 양의 데이터를 검색할 때 사용
-루트노트, 브랜치 노드, 리프노드 로 구성 >> 트리의 밸런스를 유지시키는 트리

*Clustered 인덱스 : 인덱스 생성 시, 물리적으로 정렬되므로 빠르게 연속적인 데이터 블록 검색 가능
*Bitmap 인덱스: 인덱스 내부 구조에 해당 데이터가 있으면 1, 없으면 0 으로 저장됨


*반정규화(=테이블 병합) : 여러 개의 테이블에 중복 데이터 허용 >> 무결성 보장 어려움.

*반정규화 절차 
1) 반정규화 대상 조사 및 검토
2) 반정규화 수행 전 타 방법 검토 : ex. 클러스터링(인덱스 정렬 여부)
3) 반정규화

*반정규화 기법
1) 계산된 컬럼 추가
2) 테이블 수직 분할 : 기본키 제외한 컬럼들 분할(테이블 세로로 자름)
3) 테이블 수평 분할 : 기본키 및 컬럼 유지하고, 값들을 분할(테이블 가로로 자름)
4) 테이블 병합: 슈퍼 타입과 서브 타입 관계가 발생하면 수행

*슈퍼 타입 및 서브 타입 병합 방법 (물리적 모델링에서 발생)
1) 1:1타입(OneToOne Type): 조인 많이 발생 > 관리 어려움
2) 슈퍼+서브 타입(Plus Type): 조인 발생 > 관리 어려움
3) All in One 타입(Single Type): 조인 X > 조인 성능 좋음, 입출력 성능 나쁨

*파티션 기법: 파티션을 사용하여 테이블 분할 >> 장점 : 독립적으로 백업 및 복구 가능
- Range Partition : 값의 범위 기준으로 파티션
- List Partition : 특정 값 지정하여 파티션
- Hash Partition : 해시 함수 적용하여 파티션
- Composite Partition : Range + Hash 합쳐서 파티션

*모든 속성을 참조하기 원할 때 가장 효율이 좋은(=데이터 무결성 안깨짐) 반정규화 기법
: 관계의 반정규화(관계를 중복) >> 조인 경로 및 SQL 문장 단축

*성능을 고려한 데이터 모델링 시, 고려해야 하는 절차 및 방법
-이력모델의 조정, 기본키/외래키 조정, 슈퍼타입/서브타입 조정 등을 수행
-데이터베이스 용량 산정을 수행
-데이터베이스에 발생되는 트랜잭션의 유형 파악
-데이터 모델링 시, 분석단계부터 정규화를 수행

